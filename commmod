# @router.post(
#     "/insertdisability",
#     status_code=status.HTTP_201_CREATED,
#     summary="Register a new disability member",
#     description="Create a new disability registration record following the external API format"
# )
# async def insert_disability(
#     # Personal Information - Khmer
#     disability_getinfor: Annotated[str, Form()],
#     disability_family_name: Annotated[str, Form()],
#     disability_given_name: Annotated[str, Form()],
#     disability_name: Annotated[str, Form()],
    
#     # Personal Information - English
#     disability_family_name_en: Annotated[str, Form()],
#     disability_given_name_en: Annotated[str, Form()],
#     disability_name_eng: Annotated[str, Form()],
    
#     # Basic Information
#     gender: Annotated[int, Form()],
#     national_id: Annotated[str, Form()],
#     family_code: Annotated[str, Form()],
#     phone_number: Annotated[str, Form()],
#     date_of_birth: Annotated[str, Form()],
    
#     # ID Poor Information
#     idpoor_id: Annotated[str, Form()],
#     family_code_idpoor: Annotated[str, Form()],
#     idpoor_status: Annotated[str, Form()],
    
#     # Vaccination Information
#     vacine_status: Annotated[int, Form()],
#     vacine_date: Annotated[str, Form()],
    
#     # Location and Living Situation
#     village_id: Annotated[str, Form()],
#     job: Annotated[str, Form()],
#     live_with_who: Annotated[str, Form()],
    
#     # Disability Information
#     reason_disability: Annotated[str, Form()],
#     year_start_disability: Annotated[int, Form()],
#     submit_date: Annotated[str, Form()],
#     disability_code: Annotated[str, Form()],
    
#     # Scoring Information
#     score_question: Annotated[str, Form()],
    
#     # Photo/Document Information
#     disability_photo: Annotated[UploadFile, Form()],
#     disability_photo_infor: Annotated[UploadFile, Form()],
#     disability_photo_path: Annotated[UploadFile, Form()],
#     disability_photo_doc: Annotated[UploadFile, Form()],
    
#     # Education Information
#     child_education_level: Annotated[str, Form()],
#     is_educated: Annotated[str, Form()],
#     education_level: Annotated[str, Form()],
    
#     # Employment Information
#     have_income: Annotated[str, Form()],
#     primary_job: Annotated[str, Form()],
#     find_job: Annotated[str, Form()],
#     no_job_reason: Annotated[str, Form()],
#     no_job_reason_other: Annotated[str, Form()],
    
#     # Training Information
#     no_tvet: Annotated[str, Form()],
#     is_tvet: Annotated[str, Form()],
    
#     # Support Information
#     daily_help: Annotated[str, Form()],
#     chronic_diseases: Annotated[str, Form()],
    
#     # Authentication
#     keycloak_user: Annotated[UserInSignInKeyCloak, Depends(get_user_info)],
#     db: Annotated[AsyncSession, Depends(async_get_db)],
    
#     # Optional parameters with defaults
#     score_status_live: Annotated[str, Form()] = "",
# ) -> dict:
    
#     # Save uploaded files and get paths
#     disability_photo_path = await save_upload_file(disability_photo, UPLOAD_DIR)
#     disability_photo_infor_path = await save_upload_file(disability_photo_infor, UPLOAD_DIR)
#     disability_photo_doc_path = await save_upload_file(disability_photo_doc, UPLOAD_DIR)
        
#     logger.debug("MainCreateInternal fields: %s", MainCreateInternal.model_fields.keys())
#     # Validate local DB user
#     db_user = await validate_user(keycloak_user.username, keycloak_user, db)
#     user_id = db_user["id"]

#     # Get user_id_pwd from UserProfile table (DMIS info)
#     user_profile = await crud_user_profile.get_by_user_id(db, user_id)
#     if not user_profile:
#         raise HTTPException(
#             status_code=404, 
#             detail="User profile with DMIS info not found. Please fetch /user-profile first."
#         )
#     user_profile_id = user_profile.id  # <-- This is the user_profile table's PK
#     user_id_pwd = user_profile.user_id_pwd  # DMIS ID if needed

#     logger.debug("UserProfile ID: %s", user_profile_id)
#     logger.debug("UserProfile DMIS ID: %s", user_id_pwd)

#     # --- DUPLICATE VALIDATION ---
#     existing_record = await crud_main.get_by_created_by(db, user_id)
#     if existing_record:
#         raise HTTPException(
#             status_code=status.HTTP_409_CONFLICT,
#             detail=f"A disability registration already exists for user_id {user_id_pwd}."
#         )
    
#     try:
#         # Map gender integer to Gender enum
#         gender_mapping = {0: Gender.OTHER, 1: Gender.MALE, 2: Gender.FEMALE}
#         gender_enum = gender_mapping.get(gender, Gender.MALE)

        
#         # Convert year_start_disability to a date (assuming January 1st of that year)
#         disability_date_val = date(year_start_disability, 1, 1) if year_start_disability else None
#         submit_date_val = datetime.strptime(submit_date, "%Y-%m-%d").date() if submit_date else None


#         # Create the registration data object
#         registration_data = MainCreateInternal(
#             # Map disability form fields to Main model fields
#             # family_name=disability_family_name,
#             # given_name=disability_given_name,
#             # family_name_en=disability_family_name_en,
#             # given_name_en=disability_given_name_en,
#             gender=gender_enum,
#             national_id=national_id,
#             family_code=family_code,

#             name=disability_name_eng,
#             first_name=disability_given_name_en,
#             last_name=disability_family_name_en,
#             first_name_kh=disability_given_name,
#             last_name_kh=disability_family_name,
#             disability_date=disability_date_val,

#             family_name=disability_family_name,
#             given_name=disability_given_name,
#             family_name_en=disability_family_name_en,
#             given_name_en=disability_given_name_en,


#             phone_number=phone_number,
#             idpoor_id=idpoor_id,
#             family_code_idpoor=family_code_idpoor,
#             vacine_status=str(vacine_status),
#             vacine_date=vacine_date,
#             job=job,
#             village_id=village_id,
#             dob=date_of_birth,
#             live_with_who=live_with_who,
#             reason_disability=reason_disability,
#             year_start_disability=str(year_start_disability),
#             score_question=score_question,
#             score_status_live=score_status_live,
#             is_educated=is_educated,
#             education_level=education_level,
#             have_income=have_income,
#             primary_job=primary_job,
#             find_job=find_job,
#             no_job_reason=no_job_reason,
#             no_job_reason_other=no_job_reason_other,
#             no_tvet_reason=no_tvet, 
#             is_tvet=is_tvet,
#             daily_help=daily_help,
#             chronic_diseases=chronic_diseases,
#             idpoor_status=idpoor_status,
#             disability_getinfor=disability_getinfor,
#             disability_name=disability_name,
#             submit_date=submit_date_val,
#             child_education_level=child_education_level,

#             disability_code=disability_code,
            
#             # Set required fields that don't directly map
#             gazetteer_code=village_id,  # Use village_id as gazetteer_code

#             # Save uploaded file paths
#             disability_photo=disability_photo_path,
#             disability_photo_infor=disability_photo_infor_path,
#             disability_photo_path=disability_photo_path,
#             disability_photo_doc=disability_photo_doc_path,


#             # Additional notes with unmapped fields
#             notes=f"Disability Registration - Name: {disability_name}, Name EN: {disability_name_eng}, GetInfo: {disability_getinfor}, Submit Date: {submit_date}, Photo: {disability_photo}, Photo Info: {disability_photo_infor}, Photo Path: {disability_photo_path}, Photo Doc: {disability_photo_doc}, Child Education: {child_education_level}",
            

#             # created_by=int(user_profile.user_id),
#             created_by=user_id,
#         )
        
#         # Create the main record in database
#         created_record = await crud_main.create(db=db, object=registration_data)

#         # Serialize the full DB record
#         record_data = MainRead.from_orm(created_record)


#         # Step loop score_question
#         # convert score_question to object

#         score_question_array = [
#             {"keyname": "Q1_1_1", "answer_code": "A1", "category": "C1"},
#             {"keyname": "Q1_1_2", "answer_code": "A1", "category": "C1"},
#             {"keyname": "Q1_1_3", "answer_code": "A1", "category": "C1"},
#             {"keyname": "Q1_1_4", "answer_code": "A1", "category": "C1"},
#             {"keyname": "Q1_1_5", "answer_code": "A2", "category": "C1"},
#             {"keyname": "Q1_1_6", "answer_code": "Ä2", "category": "C1"},
#             {"keyname": "Q1_1_7", "answer_code": "A2", "category": "C1"},
#         ]


#         # Decide: use frontend data or fallback to static
#         if score_question and score_question.strip():
#             try:
#                 questions = json.loads(score_question)
#                 if not isinstance(questions, list):
#                     raise ValueError("score_question must be a JSON array")
#                 raw_json_to_save = score_question.strip()
#                 logging.debug("Using score_question from frontend")
#             except json.JSONDecodeError as e:
#                 raise HTTPException(status_code=400, detail=f"Invalid JSON in score_question: {e}")
#         else:
#             questions = score_question_array
#             raw_json_to_save = json.dumps(score_question_array)  # Convert static list → JSON string
#             logging.debug("No score_question provided → using static default answers")

#         # Save the raw JSON string into main.score_question field
#         created_record.score_question = raw_json_to_save
#         await db.commit()
#         await db.refresh(created_record)

#         saved_count = 0
#         for q in questions:
#             keyname = q["keyname"]
#             answer_code = q["answer_code"]
#             category_code = q.get("category") or q.get("category_code")

#             question_answer_data = QuestionAnswerCreateInternal(
#                 main_id=created_record.id,
#                 question_code=keyname,
#                 category_code=category_code,
#                 answer_code=answer_code
#             )

#             await crud_question_answer.create_question_answer(db=db, qa_data=question_answer_data)
#             saved_count += 1

#         logging.debug(f"Inserted {saved_count} score answers into question_answer table")

#         # questions = [{"keyname":"Q1_4_1","keyscore":1, "answer_code": "A1", "category_code": "C1"},{"keyname":"Q1_4_6","keyscore":3, "answer_code": "A2", "category_code": "C2"}]

#         # for q in questions:
#         #     keyname = q["keyname"]
#         #     answer_code = q["answer_code"]
#         #     category_code = q["category_code"]
#         #     crud_question_answer_data = QuestionAnswerInternal(
#         #         main_id=created_record.id,
#         #         question_code=keyname,
#         #         category_code=category_code,
#         #         answer_code=answer_code
#         #     )

#         #     question_answer_created_record = await crud_question_answer.create(db=db, object=crud_question_answer_data)

        
        
#         # return {
#         #     "message": f"Disability registration created successfully for {disability_name_eng}",
#         #     "disability_id": created_record.id,
#         #     "status": "registered",
#         #     "record_id": created_record.id,
#         #     "user_id": user_id_pwd,
#         #     "created_by": str(user_id_pwd)
#         # }

#         return {
#             "error": False,
#             "message": "success",
#             "data": record_data.model_dump(by_alias=True)  # <- important
#         }
        
#     except ValueError as e:
#         raise HTTPException(
#             status_code=status.HTTP_400_BAD_REQUEST,
#             detail=str(e)
#         )
#     except IntegrityError as e:
#         raise HTTPException(
#             status_code=status.HTTP_409_CONFLICT,
#             detail=f"Database integrity error - possibly duplicate national ID: {str(e)}"
#         )
#     except Exception as e:
#         raise HTTPException(
#             status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
#             detail=f"Failed to create disability registration: {str(e)}"
#         )


================
==========

# @router.get(
#     "/{main_record_id}",
#     response_model=MainRecordResponse,
#     summary="Get main record by ID",
# )
# async def get_main_record(
#     main_record_id: int,
#     keycloak_user: Annotated[UserInSignInKeyCloak, Depends(get_user_info)],
#     db: Annotated[AsyncSession, Depends(async_get_db)],
# ):
#     await validate_user(keycloak_user.username, keycloak_user, db)

#     try:
#         record = await crud_main.get(db=db, id=main_record_id)

#         if not record or record.get("is_deleted"):
#             return MainListResponse(
#                 error=True,
#                 message="Fail for fetching detail main record",
#                 data=[]
#             )

#         main_read = MainRead(**record)

#         return MainRecordResponse(
#             error=False,
#             message="Successful for fetching detail main record",
#             data=[main_read] 
#         )

#     except Exception as e:
#         return MainRecordResponse(
#             error=True,
#             message=f"Fail for fetching detail main record: {str(e)}",
#             data=[]
#         )



================
==========

# @router.get(
#     "/",
#     response_model=MainListResponse,
#     summary="Get all main records",
#     description="Retrieve all active main records with optional filtering"
# )
# async def get_main_records(
#     keycloak_user: Annotated[UserInSignInKeyCloak, Depends(get_user_info)],
#     db: Annotated[AsyncSession, Depends(async_get_db)],
#     skip: int = 0,
#     limit: int = 100,
#     status_filter: AccountStatus | None = None,
#     gazetteer_code: str | None = None,
# ):
#     """
#     Get all main records with optional filtering.
    
#     Args:
#         keycloak_user: Authenticated user information
#         db: Database session
#         skip: Number of records to skip
#         limit: Maximum number of records to return
#         status_filter: Filter by account status
#         gazetteer_code: Filter by gazetteer code
        
#     Returns:
#         List of main records
#     """
    
#     # Validate user
#     await validate_user(keycloak_user.username, keycloak_user, db)
    
#     try:
#         if status_filter:
#             records = await crud_main.get_by_status(db=db, status=status_filter, skip=skip, limit=limit)
#         elif gazetteer_code:
#             records = await crud_main.get_by_gazetteer_code(db=db, gazetteer_code=gazetteer_code, skip=skip, limit=limit)
#         else:
#             records = await crud_main.get_all_active(db=db, skip=skip, limit=limit)
        
#         result = [
#             MainRead(
#                 id=record.id,
#                 name=record.name,
#                 phone_number=record.phone_number,
#                 first_name=record.first_name,
#                 last_name=record.last_name,
#                 first_name_kh=record.first_name_kh,
#                 last_name_kh=record.last_name_kh,
#                 gender=record.gender,
#                 dob=record.dob,
#                 have_eq_card=record.have_eq_card,
#                 eq_card=record.eq_card,
#                 disability_date=record.disability_date,
#                 gazetteer_code=record.gazetteer_code,
#                 status=record.status,
#                 notes=record.notes,
#                 spid=record.spid,
#                 latitude=record.latitude,
#                 longitude=record.longitude,
#                 remarks=record.remarks,
#                 created_by=record.created_by,
#                 updated_by=record.updated_by,
#                 score_question=record.score_question,
#                 disability_code=record.disability_code,
#                 family_name=record.family_name,
#                 given_name=record.given_name,
#                 family_name_en=record.family_name_en,
#                 given_name_en=record.given_name_en,

#                 # disability_photo=record.disability_photo_path,
#                 # disability_photo_infor=record.disability_photo_infor,
#                 # disability_photo_doc=record.disability_photo_doc,

#                 disability_getinfor=record.disability_getinfor,
#                 disability_name=record.disability_name,
#                 idpoor_status=record.idpoor_status,
#                 vacine_status=record.vacine_status,
#                 vacine_date=record.vacine_date,
#                 live_with_who=record.live_with_who,
#                 reason_disability=record.reason_disability,
#                 year_start_disability=record.year_start_disability,
#                 submit_date=record.submit_date,
#                 child_education_level=record.child_education_level,
#                 is_educated=record.is_educated,
#                 education_level=record.education_level,
#                 have_income=record.have_income,
#                 primary_job=record.primary_job,
#                 find_job=record.find_job,
#                 no_job_reason=record.no_job_reason,
#                 no_job_reason_other=record.no_job_reason_other,
#                 no_tvet=record.no_tvet_reason,
#                 is_tvet=record.is_tvet,
#                 daily_help=record.daily_help,
#                 chronic_diseases=record.chronic_diseases,
#                 score_status_live=record.score_status_live,
                
#             )
#             for record in records
#         ]
    
#         return {
#             "error": False,
#             "message": "Successful fetching main records",
#             "data": result
#         }
        
#     except Exception as e:
#         return {
#             "error": True,
#             "message": f"Failed to fetch main records: {str(e)}",
#             "data": []
#         }


ឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲ
ឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲឲ

# async def get_asset_url_test(
#     keycloak_user: Annotated[UserInSignInKeyCloak, Depends(get_user_info)],
#     db: Annotated[AsyncSession, Depends(async_get_db)]
# ) -> str:

#     return get_asset_url(file_path="public/disability_type.jpg", token=keycloak_user.token)


